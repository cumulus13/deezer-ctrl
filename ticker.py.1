import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import os
from pathlib import Path
from configset import configset
from mpd import MPDClient
from pydebugger.debug import debug
from make_colors import make_colors
import mimetypes
import re
from unidecode import unidecode
import requests
from xnotify import notify
import time
from multiprocessing import Process
import traceback
from urllib.parse import quote
import deezer_art
from datetime import datetime
import bitmath
import mpd

class LastFM(object):
    CONFIGNAME = str(Path(__file__).parent / 'ticker.ini')
    CONFIG = configset(CONFIGNAME)

    @classmethod
    def search_track(self, artist, track):
        url = 'http://ws.audioscrobbler.com/2.0/'
        params = {
            'method': 'track.search',
            'track': track,
            'artist': artist,
            'api_key': self.CONFIG.get_config('lastfm', 'api') or "c725344c28768a57a507f014bdaeca79",
            'format': 'json'
        }

        response = requests.get(url, params=params)
        data = response.json()
        if data['results']['trackmatches']['track']:
            return data['results']['trackmatches']['track'][0]
        else:
            return None

    @classmethod
    def get_track_info(self, artist, track):
        track_info = self.search_track(artist, track)
        if track_info:
            track_name = track_info['name']
            artist_name = track_info['artist']
            url = 'http://ws.audioscrobbler.com/2.0/'
            params = {
                'method': 'track.getInfo',
                'track': track_name,
                'artist': artist_name,
                'api_key': self.CONFIG.get_config('lastfm', 'api') or "c725344c28768a57a507f014bdaeca79",
                'format': 'json'
            }
            response = requests.get(url, params=params)
            data = response.json()
            debug(data = data)
            if 'track' in data and 'album' in data['track']:
                album_info = data['track']['album']
                return {
                    'album_name': album_info['title'],
                    'album_url': album_info['url'],
                    'album_image': album_info['image'][-1]['#text'] if album_info['image'] else None
                }

        return {
            'album_name': '',
            'album_url': '',
            'album_image': str(Path(__file__).parent / 'default_cover.png')
        }


class Normalization:
    
    @classmethod
    def normalization_name(self, name):
        name = name.strip()
        name = re.sub("\: ", " - ", name)
        name = re.sub("\?|\*", "", name)
        name = re.sub("\:", "-", name)
        name = re.sub("\.\.\.", "", name)
        name = re.sub("\.\.\.", "", name)
        name = re.sub(" / ", " - ", name)
        name = re.sub("/", "-", name)
        name = re.sub(" ", ".", name)
        name = name.encode('utf-8', errors = 'ignore').strip()
        name = unidecode(name.decode('utf-8', errors = 'ignore')).strip()
        name = re.sub("\^", "", name)
        name = re.sub("\[|\]|\?", "", name)
        name = re.sub("  ", " ", name)
        name = re.sub("   ", " ", name)
        name = re.sub("    ", " ", name)
        name = re.sub("\(|\)", "", name)
        name = name.strip()
        while 1:
            if name.strip()[-1] == ".":
                name = name.strip()[:-1]
            else:
                break
        debug(name = name)
        return name
    

class MPD(MPDClient):
    def __init__(self, host='localhost', port=6600):
        super().__init__()  # Initialize the parent MPDClient class
        self.CONFIGFILE = str(Path(__file__).parent / "ticker.ini")
        self.CONFIG = configset(self.CONFIGFILE)
        
        self.HOST = os.getenv('MPD_HOST') or self.CONFIG.get_config('mpd', 'host', '127.0.0.1')
        self.PORT = os.getenv('MPD_PORT') or self.CONFIG.get_config('mpd', 'port', 6600)
        self.CONFIGFILE_NEXT = str(Path(__file__).parent / Normalization.normalization_name(self.HOST.strip()).replace(".", "_")) + ".ini"
        self.CONFIG = configset(self.CONFIGFILE_NEXT)
        
        self.connect_to_server()

    def connect_to_server(self):
        while True:
            try:
                self.connect(self.HOST, self.PORT)
                print("Connected to MPD server.")
                break
            except ConnectionRefusedError:
                print("Connection refused. Retrying in 1 second...")
                time.sleep(1)
            except:
                print(make_colors(traceback.format_exc(), 'lw', 'r'))

    @staticmethod
    def connection_check1(fn):
        def wrapper(self, *args, **kwargs):
            def try_connect():
                while True:
                    try:
                        self.connect(self.HOST, self.PORT)
                        print("Reconnected to MPD server.")
                        #self.update_song_info()
                        #self.update_image()
                        break
                    except Exception as e:
                        print(f"Reconnection attempt failed: {e}")
                        self.update_song_info_initialize_clear()
                        self.root.after(1000, try_connect)  # Retry connection every second
                        if os.getenv('TRACEBACK') == '1':
                            print(make_colors("ERROR [2]:", 'lw', 'r') + " " + make_colors(traceback.format_exc(), 'lw', 'r'))
                        else:
                            print(make_colors("ERROR [1]:", 'lw', 'r') + " " + make_colors(str(e), 'lw', 'r'))
                        if str(e) == 'Already connected': self.disconnect()                        
                        break  # Exit the while loop, the next attempt will be scheduled

            while True:  # Keep trying to call the function until successful
                try:
                    return fn(self, *args, **kwargs)
                except Exception as e:
                    ep = e
                    print(f"Connection lost: {ep}")
                    if str(ep) == 'Already connected':
                        try:
                            self.currentsong()
                            break
                        except:
                            print(make_colors("ERROR [0]:", 'lw', 'r') + " " + make_colors(traceback.format_exc(), 'lw', 'r'))
                    
                    print("Connection lost. Reconnecting...")                                            
                    self.update_song_info_initialize_clear()
                    self.root.after(1000, try_connect)  # Start reconnect attempts
                    break  # Exit the while loop, the next attempt will be scheduled
        return wrapper
    
    @staticmethod
    def connection_check(fn):
        def wrapper(self, *args, **kwargs):
            debug(args = args, debug = 1)
            debug(kwargs = kwargs, debug = 1)
            while True:  # Keep trying to call the function until successful
                try:
                    debug(fn = fn, debug = 1)
                    debug(fn__name__0 = fn.__name__, debug = 1)
                    debug(dir_fn = dir(fn), debug = 1)
                    debug(args = args, debug = 1)
                    debug(kwargs = kwargs, debug = 1)
                    
                    return fn(self, *args, **kwargs)
                #except (mpd.ConnectionError, BrokenPipeError):
                except Exception as e:
                    self.status = 'error'
                    debug(fn__name__1 = fn.__name__, debug = 1)
                    #if fn.__name__ in ['update_song_info', 'update_text_on_canvas']:
                        #self.status == 'error'
                        #fn(self, *args, **kwargs)()
                    ep = e
                    while True:
                        if str(ep) == 'Already connected':
                            try:
                                self.currentsong()
                                self.status == 'finish'
                                break
                            except:
                                print(make_colors("ERROR [0]:", 'lw', 'r') + " " + make_colors(traceback.format_exc(), 'lw', 'r'))
                        print("Connection lost. Reconnecting...")                        
                        try:
                            self.connect(self.HOST, self.PORT)
                            print("Reconnected to MPD server.")
                            break  # Exit inner loop once reconnected
                        except Exception as e:
                            if os.getenv('TRACEBACK') == '1':
                                print(make_colors("ERROR [2]:", 'lw', 'r') + " " + make_colors(traceback.format_exc(), 'lw', 'r'))
                            else:
                                print(make_colors("ERROR [1]:", 'lw', 'r') + " " + make_colors(str(e), 'lw', 'r'))
                            if str(e) == 'Already connected':
                                self.disconnect()
                        time.sleep(1)
        return wrapper

class Music:
    def __init__(self, host='localhost', port=6600):
        self.client = MPD(host, port)
        
    @MPD.connection_check
    def currentsong(self):
        return self.client.currentsong()  # Directly call currentsong on the MPD instance        
        
class Ticker:
    def __init__(self, root, text=" Welcome to the MPD ticker! "):
        self.client = MPDClient()
        self.timer_id = None
        self.timer_id_init = None
        self.timer_id_clear = None
        self.timer_id_error = None
        self.timer_id_init_clear = None        
        self.CONFIGFILE = str(Path(__file__).parent / "ticker.ini")
        self.CONFIG = configset(self.CONFIGFILE)
        
        self.HOST = os.getenv('MPD_HOST') or self.CONFIG.get_config('mpd', 'host', '127.0.0.1')
        self.PORT = os.getenv('MPD_PORT') or self.CONFIG.get_config('mpd', 'port', 6600)
        self.CONFIGFILE_NEXT = str(Path(__file__).parent / self.normalization_name(self.HOST.strip()).replace(".", "_")) + ".ini"
        self.CONFIG = configset(self.CONFIGFILE_NEXT)
        
        debug(self_HOSTNAME = self.HOST)
        debug(self_POT = self.PORT, debug = 1)
                
        self.process = Process(target=self.connection_watch)
        #self.process.start()
        
        self.notify = notify('MPD-Ticker', ['New Song'])
    
        self.root = root
        self.root.overrideredirect(True)  # Remove window decorations
        self.root.attributes("-topmost", True)  # Keep window on top initially
        self.root.attributes("-alpha", self.CONFIG.get_config('transparent', 'level', 60) / 100)
        self.load_position()  # Load window position
        self.child_window = None        
        
        self.style = ttk.Style()
        
        self.style.configure("Custom.TFrame", background=self.CONFIG.get_config('color', 'background', "#353535"))
    
        # Configure styles for title, album, and artist
        self.title_color = self.CONFIG.get_config('color', 'title', "#00FFFF")
        self.album_color = self.CONFIG.get_config('color', 'album', "#FFFF00")
        self.artist_color = self.CONFIG.get_config('color', 'artist', "#21FF15")
        
        self.title_font = (self.CONFIG.get_config('font', 'title_name', "Helvetica"), self.CONFIG.get_config('font', 'title_size', 14))
        self.album_font = (self.CONFIG.get_config('font', 'album_name', "Helvetica"), self.CONFIG.get_config('font', 'album_size', 12))
        self.artist_font = (self.CONFIG.get_config('font', 'artist_name', "Helvetica"), self.CONFIG.get_config('font', 'artis_size', 12))
    
        self.frame = ttk.Frame(root, style="Custom.TFrame", padding = 0, borderwidth = 0)
        self.frame.pack(fill=tk.BOTH, expand=True, anchor='n')  # Align to top
    
        #self.canvas = tk.Canvas(self.frame, background=self.CONFIG.get_config('color', 'background', "#353535"), width=600, height=100)
        self.canvas = tk.Canvas(self.frame, background=self.CONFIG.get_config('color', 'background', "#353535"), highlightthickness=0, borderwidth=0, width=600, height=100)
        self.canvas.pack(fill=tk.BOTH, expand=True)
    
        self.x = 0  # Starting position of the text
        self.ticker_job = self.root.after(50, self.update_ticker)  # Start the ticker
    
        # Initialize MPD client
        #self.connect_to_mpd()
        self.current_song = None
        
        self.status = None
        
        #self.update_song_info()
        self.is_first = True
        
        while 1:
            try:
                self.client.connect(self.HOST, self.PORT)
                debug(self_is_first = self.is_first, debug = 1)
                if self.is_first:
                    self.update_song_info()
                    self.is_first = False
                self.status = "finish"
                break
            except Exception as e:
                self.status = 'error'
                
                if str(e) == "Already connected":
                    try:
                        self.client.status()
                        self.status = "finish"
                        break
                    except:
                        pass
                debug(self_is_first = self.is_first, debug = 1)
                if self.is_first:
                    self.update_song_info()
                    self.is_first = False                
                print(make_colors("ERROR [0]:", 'lw', 'r'), str(e), "," + make_colors("re-connecting ...", 'b', 'ly'))
                if os.getenv('TRACEBACK') == '1':
                    print(make_colors("ERROR [0]:", 'lw', 'r'), " " + traceback.format_exc())
            time.sleep(1)
            
        # Start fetching song info
        #self.update_song_info()
    
        # Bind keys to quit the application
        #self.root.bind('<Escape>', self.quit)
        #self.root.bind('<q>', self.quit)
        #self.root.bind('<x>', self.quit)
        
        self.root.bind('<Escape>', self.quit_or_close_child)
        self.root.bind('<q>', self.quit_or_close_child)
        self.root.bind('<x>', self.quit_or_close_child)        
        
        self.root.bind('<s>', self.show_full_image)
        
        self.root.bind('<p>', self.play)        
        self.root.bind('<Shift-P>', self.pause)        
        self.root.bind('<n>', self.next)
        self.root.bind('<Shift-N>', self.previous)        
    
        # Bind keys to toggle always on top
        self.root.bind('a', self.set_always_on_top)
        self.root.bind('<Shift-A>', self.set_normal)
    
        # Bind window movement to save position
        self.root.bind('<Configure>', self.save_position)
    
        # Bind mouse events for dragging
        self.canvas.bind("<Button-1>", self.start_move)
        self.canvas.bind("<B1-Motion>", self.do_move)        
            
        
    
    def connect(self, host = None, port = None):
        host = host or self.HOST
        port = port or self.PORT
        
        debug(host = host)
        debug(port = port)
        
        if isinstance(port, str) and str(port).isdigit(): port = int(port)
        if not str(port).isdigit(): port = 6600
        
        self.client.connect(host, port)
        return self.client
    
    def disconnect(self):
        return self.client.disconnect()
    
    @MPD.connection_check
    def play(self, event):
        #try:
        self.client.play()
        #except:
            #self.connect_to_mpd()
    
    @MPD.connection_check
    def pause(self, event):
        #try:
        self.client.pause()
        #except:
            #self.connect_to_mpd()
    
    @MPD.connection_check
    def next(self, event):
        #try:
        self.client.next()
        #except:
            #self.connect_to_mpd()
    
    @MPD.connection_check
    def previous(self, event):
        #try:
        self.client.previous()
        #except:
            #self.connect_to_mpd()
    
    def logger(self, message, status="info"):
        logfile = os.path.join(os.path.dirname(os.path.realpath(__file__)), os.path.basename(self.CONFIG.configname).split(".")[0] + ".log")
        if not os.path.isfile(logfile):
            lf = open(logfile, 'wb')
            lf.close()
        real_size = bitmath.getsize(logfile).kB.value
        max_size = self.CONFIG.get_config("log", 'max_size')
        debug(max_size = max_size)
        if max_size:
            debug(is_max_size = True)
            try:
                max_size = bitmath.parse_string_unsafe(max_size).kB.value
            except:
                max_size = 0
            if real_size > max_size:
                try:
                    os.remove(logfile)
                except Exception as e:
                    print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} [{make_colors('logger', 'lw', 'm')}] {make_colors('[ERROR]', 'lw','r')} {make_colors('[1]', 'b', 'ly')} {make_colors(e, 'lw', 'r')}")
                    print(make_colors(traceback.format_exc(), 'lw', 'r'))
                try:
                    lf = open(logfile, 'wb')
                    lf.close()
                except:
                    print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} [{make_colors('logger', 'lw', 'm')}] {make_colors('[ERROR]', 'lw','r')} {make_colors('[2]', 'b', 'ly')} {make_colors(e, 'lw', 'r')}")
                    print(make_colors(traceback.format_exc(), 'lw', 'r'))


        str_format = datetime.strftime(datetime.now(), "%Y/%m/%d %H:%M:%S.%f") + " - [{}] {}".format(status, message) + "\n"
        with open(logfile, 'ab') as ff:
            if sys.version_info.major == 3:
                ff.write(bytes(str_format, encoding='utf-8'))
            else:
                ff.write(str_format)
                
    def quit_or_close_child(self, event):
        if self.child_window is not None:
            self.close_child()
        else:
            self.quit()
            
    def start_move(self, event):
        self.x_offset = event.x
        self.y_offset = event.y
    
    def do_move(self, event):
        x = self.root.winfo_pointerx() - self.x_offset
        y = self.root.winfo_pointery() - self.y_offset
        self.root.geometry(f"+{x}+{y}")

    def schedule_image_resize(self):
        self.root.after(100, self.resize_image_to_text_height)
    
    def connection_watch(self):
        while True:
            try:
                print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} [{make_colors('Connection Watch', 'lw', 'm')}] {make_colors('Start connecting ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                self.client.connect(os.getenv('MPD_HOST') or self.CONFIG.get_config('mpd', 'host', '127.0.0.1'), int(os.getenv('MPD_PORT', 6600)) or self.CONFIG.get_config('mpd', 'port', 6600))
                status = self.client.status()
                print(status)
            except:
                try:
                    self.client.disconnect()
                except:
                    pass
                self.client.connect(os.getenv('MPD_HOST') or self.CONFIG.get_config('mpd', 'host', '127.0.0.1'), int(os.getenv('MPD_PORT', 6600)) or self.CONFIG.get_config('mpd', 'port', 6600))
            time.sleep(self.CONFIG.get_config('watch', 'sleep', '5') or 5)
            
    def connect_to_mpd(self):
        while 1:
            print(make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly') + " " +  make_colors("check process background [1]:", 'lw', 'm') + " " + make_colors(str(self.process.is_alive()), 'lw', 'r'))
            #if not self.process.is_alive():
                #self.process.start()            
            try:
                self.client.connect(os.getenv('MPD_HOST') or self.CONFIG.get_config('mpd', 'host', '127.0.0.1'), int(os.getenv('MPD_PORT', 6600)) or self.CONFIG.get_config('mpd', 'port', 6600))
                status = self.client.status()
                #print(status)
                break
            except Exception as e:
                if str(e) != 'Already connected':
                    print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Could not connect to MPD', 'lw','r')} {make_colors('[1]', 'b', 'ly')}: {make_colors(e, 'lw','r')}")
                if os.getenv('traceback') == '1': print(traceback.format_exc())                    
                try:
                    print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Try get current song ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                    self.client.currentsong()
                except:
                    print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('ERROR', 'lw', 'r')} {make_colors('Try get current song ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                    try:
                        print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Try disconnecting ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                        self.client.disconnect()
                    except:
                        print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('ERROR', 'lw', 'r')} {make_colors('Try disconnecting ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                        if os.getenv('traceback') == '1': print(traceback.format_exc())
                    try:
                        print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Try re-Connecting ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                        self.client.connect(os.getenv('MPD_HOST') or self.CONFIG.get_config('mpd', 'host', '127.0.0.1'), int(os.getenv('MPD_PORT', 6600)) or self.CONFIG.get_config('mpd', 'port', 6600))
                        print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('SUCCESS', 'b', 'y')} {make_colors('Try disconnecting ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                        break
                    except Exception as e:
                        print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('ERROR', 'lw', 'r')} {make_colors('Try re-Connecting ...', 'lw','bl')} {make_colors('[1]', 'b', 'ly')}")
                        print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Could not connect to MPD', 'lw','r')} {make_colors('[2]', 'b', 'ly')}: {make_colors(e, 'lw','r')}")
            print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('ERROR', 'lw', 'r')} {make_colors(f'Sleeping for ', 'lw','bl')} {make_colors(self.CONFIG.get_config('reconnection', 'sleep', '1') or 1,  'lw', 'r')} seconds ... {make_colors('[1]', 'b', 'ly')}")
            time.sleep(self.CONFIG.get_config('reconnection', 'sleep', '1') or 1)

    def load_position(self):
        if self.CONFIG.get_config('geometry', 'x') and self.CONFIG.get_config('geometry', 'y') and self.CONFIG.get_config('geometry', 'width') and self.CONFIG.get_config('geometry', 'height'):
            self.root.geometry(f"{self.CONFIG.get_config('geometry', 'width')}x{self.CONFIG.get_config('geometry', 'height')}+{self.CONFIG.get_config('geometry', 'x')}+{self.CONFIG.get_config('geometry', 'y')}")
        else:
            self.root.geometry("500x45+100+100")  # Default position and size

    def save_position(self, event=None):
        if event:
            x = self.root.winfo_x()
            y = self.root.winfo_y()
            width = self.root.winfo_width()
            height = self.root.winfo_height()
            self.CONFIG.write_config('geometry', 'x', x)
            self.CONFIG.write_config('geometry', 'y', y)
            self.CONFIG.write_config('geometry', 'width', width)
            self.CONFIG.write_config('geometry', 'height', height)

    #@MPD.connection_check   
    def update_text_on_canvas(self, image_width):
        debug(self_status = self.status, debug = 1)
        host_str = ''
        if not self.HOST in ['127.0.0.1', 'localhost', '1::']: host_str = f" [{self.HOST}]"
        status_str = ''
        if not self.status == 'error':
            status = self.client.status()
            if status.get('state') != 'play': status_str = ' [pause]' 
        else:
            status = {}
            status_str = ' [disconnected]'
            
        if not self.current_song and not self.status == 'error':
            self.current_song = self.client.currentsong()
            
        debug(self_status = self.status, debug = 1)
        debug(self_current_song = self.current_song, debug = 1)
        
        debug(host_str = host_str)        
        # Ensure the text is overlayed on the image
        if self.status == 'error' or not self.current_song:
            self.canvas.delete("text")
            # Adjust text coordinates to place it to the left of the resized image with more compact spacing
            self.canvas.create_text(image_width + 20, 10, text='disconnected' + status_str + host_str, fill=self.title_color, font=self.title_font, anchor='nw', tags="text")
            self.canvas.create_text(image_width + 20, 23, text='disconnected', fill=self.album_color, font=self.album_font, anchor='nw', tags="text")
            self.canvas.create_text(image_width + 20, 35, text='disconnected', fill=self.artist_color, font=self.artist_font, anchor='nw', tags="text")            
        else:
            self.canvas.delete("text")
            # Adjust text coordinates to place it to the left of the resized image with more compact spacing
            self.canvas.create_text(image_width + 20, 10, text=self.current_song.get('title', 'Unknown Title') + status_str + host_str, fill=self.title_color, font=self.title_font, anchor='nw', tags="text")
            self.canvas.create_text(image_width + 20, 23, text=f"Album: {self.current_song.get('album', 'Unknown Album')} ({self.current_song.get('date', 'Unknown Year')})", fill=self.album_color, font=self.album_font, anchor='nw', tags="text")
            self.canvas.create_text(image_width + 20, 35, text=f"Artist: {self.current_song.get('artist', 'Unknown Artist')}", fill=self.artist_color, font=self.artist_font, anchor='nw', tags="text")
    
    def resize_image_to_text_height(self):
        self.root.update_idletasks()  # Ensure window is fully rendered
    
        # Get the height of the text elements
        text_height = 10 + 20 + 20  # Adjust these values as needed for spacing and font size
    
        # Calculate the width and height for the image
        aspect_ratio = self.original_image.width / self.original_image.height
        image_height = text_height - 12
        image_width = int(image_height * aspect_ratio)
    
        #print(f"Image size: {image_width}x{image_height}")  # Debugging statement
    
        # Resize the image to match the calculated size
        resized_image = self.original_image.resize((image_width, image_height), Image.LANCZOS)
        self.image = ImageTk.PhotoImage(resized_image)
    
        # Update the canvas with the resized image
        self.canvas.delete("image")
        self.canvas.create_image(10, 10, image=self.image, anchor='nw', tags="image")
        self.canvas.tag_bind("image", "<Button-1>", self.show_full_image)
        #print("Image added to canvas")  # Debugging statement
    
        # Ensure text is on top of the image
        self.update_text_on_canvas(image_width)
        
    def show_full_image(self, event):
        if self.child_window is not None:
            return
    
        self.child_window = tk.Toplevel(self.root)
        self.child_window.title("Full Image")
        self.child_window.geometry("800x800")
    
        # Resize image to fit within 800 pixels
        aspect_ratio = self.original_image.width / self.original_image.height
        if self.original_image.width > 800 or self.original_image.height > 800:
            if self.original_image.width > self.original_image.height:
                new_width = 800
                new_height = int(800 / aspect_ratio)
            else:
                new_height = 800
                new_width = int(800 * aspect_ratio)
        else:
            new_width = self.original_image.width
            new_height = self.original_image.height
    
        resized_image = self.original_image.resize((new_width, new_height), Image.LANCZOS)
        self.full_image = ImageTk.PhotoImage(resized_image)
    
        label = tk.Label(self.child_window, image=self.full_image)
        label.pack(expand=True)
    
        # Bind keys to close child window
        self.child_window.bind('<Escape>', self.close_child)
        self.child_window.bind('<q>', self.close_child)
        self.child_window.bind('<x>', self.close_child)
    
    def close_child(self, event=None):
        if self.child_window is not None:
            self.child_window.destroy()
            self.child_window = None
    
    def update_ticker(self):
        self.root.attributes("-alpha", self.CONFIG.get_config('transparent', 'level', 60) / 100)
        self.canvas.move("all", -2, 0)  # Move all elements to the left
        bbox = self.canvas.bbox("all")
        if bbox[2] < 0:  # If the text has moved off the screen
            self.canvas.move("all", self.root.winfo_width(), 0)  # Move it back to the right side
        self.ticker_job = self.root.after(self.CONFIG.get_config('sleep', 'time', 100), self.update_ticker)  # Update ticker every 100 milliseconds

    def normalization_name(self, name):
        name = name.strip()
        if not name:
            return ''
        name = re.sub("\: ", " - ", name)
        name = re.sub("\?|\*", "", name)
        name = re.sub("\:", "-", name)
        name = re.sub("\.\.\.", "", name)
        name = re.sub("\.\.\.", "", name)
        name = re.sub(" / ", " - ", name)
        name = re.sub("/", "-", name)
        name = re.sub(" ", ".", name)
        name = name.encode('utf-8', errors = 'ignore').strip()
        name = unidecode(name.decode('utf-8', errors = 'ignore')).strip()
        name = re.sub("\^", "", name)
        name = re.sub("\[|\]|\?", "", name)
        name = re.sub("  ", " ", name)
        name = re.sub("   ", " ", name)
        name = re.sub("    ", " ", name)
        name = re.sub("\(|\)", "", name)
        name = name.strip()
        while 1:
            if name.strip()[-1] == ".":
                name = name.strip()[:-1]
            else:
                break
        debug(name = name)
        return name

    #@MPD.connection_check
    def find_cover_art(self):
        
        if self.status == 'error':
            return str(Path(__file__).parent / 'no_cover.png')
        #try:
        current_song = self.client.currentsong()
        temp_dir = str(Path(os.getenv('temp', '/tmp')) / Path('cover') / Path((self.normalization_name(current_song.get('artist')) or 'Unknown Artist')))
        if not os.path.isdir(temp_dir):
            os.makedirs(temp_dir)
            
        if os.path.isfile(str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + ".jpg"))):
            print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('use cover [1]:', 'lw', 'm')} {make_colors(str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + '.jpg')), 'b','y')}")
            debug(cover = str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + ".jpg")), debug = 1)
            return str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + ".jpg"))
        elif os.path.isfile(str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + ".png"))):
            print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('use cover [2]:', 'lw', 'm')} {make_colors(str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + '.png')), 'b','y')}")
            debug(cover = str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + ".png")), debug = 1)
            return str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + ".png"))
        #except Exception as e:
            #if str(e) == 'Already connected':
                #self.client.disconnect()
            #self.connect_to_mpd()
            #return self.find_cover_art()

        try:
            current_song = self.client.currentsong()
            debug(current_song = current_song)
            song = current_song.get('file', '')
            debug(song = song)
            if song:
                picture = self.client.readpicture(song)
                debug(picture = picture.keys())
                if picture.get('binary'):
                    debug(picture = len(picture.get('binary')))
                    ext = mimetypes.guess_extension(picture.get('type'))
                    debug(ext = ext)
                    temp_path = str(Path(temp_dir) / Path((self.normalization_name(current_song.get('title')) or 'No Title') + (ext or ".jpg")))
                    debug(temp_path = temp_path)
                    with open(temp_path, 'wb') as img_file:
                        img_file.write(picture.get('binary'))
                    print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('use cover [3]:', 'lw', 'm')} {make_colors(temp_path, 'b','y')}")
                    debug(cover = temp_path, debug = 1)
                    return temp_path

        except Exception as e:
            print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('No embedded cover art found:', 'lw', 'bl')} {make_colors(e, 'lw', 'r')}")

        cover = deezer_art.get_album_art(current_song.get('artist'), current_song.get('title'), current_song.get('album'), True)
        if not cover:
            return self.find_cover_art_lastfm(current_song)
        else:
            print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('use cover [4]:', 'lw', 'm')} {make_colors(cover, 'b','y')}")
            return cover
    
    def find_cover_art_lastfm(self, data=None, to_file = True):
        print(make_colors("start get LastFM cover ...", 'lw', 'r'))
        def get_image(url):
            while 1:
                try:
                    a = requests.get(url, stream = True)
                    break
                except:
                    time.sleep(1)
            
            return a.content
        
        api_key = self.CONFIG.get_config('lastfm', 'api') or "c725344c28768a57a507f014bdaeca79"
        if not data:
            current_song = self.client.currentsong()
            artist = current_song.get('artist')
            album = current_song.get('album')
            title = current_song.get('title')
        else:
            artist = data.get('artist')
            album = data.get('album')
            title = data.get('title')

        temp_dir = str(Path(os.getenv('temp', '/tmp')) / Path('cover') / Path((self.normalization_name(artist) or 'Unknown Artist')))
        if not os.path.isdir(temp_dir):
            os.makedirs(temp_dir)
        debug(temp_dir = temp_dir, debug = 1)
        if artist and album:
            #url = f"http://ws.audioscrobbler.com/2.0/?method=album.getinfo&api_key={api_key}&artist={quote(artist)}&album={quote(album)}&format=json"
            url = f"http://ws.audioscrobbler.com/2.0/"
            params = {
                'method': 'album.getinfo',
                'api_key': api_key,
                'artist': quote(artist),
                'album': quote(album),
                'format': 'json',
            }
            a = requests.get(url, params = params)
            if a.status_code == 200:
                try:
                    url1 = a.json()['album']['image'][-1]['#text']
                    temp_path = str(Path(os.getenv('temp', '/tmp')) / Path('temp_cover' + os.path.splitext(url1)[-1]))
                    with open(temp_path, 'wb') as f:
                        f.write(requests.get(url1).content)
                    return temp_path
                except Exception as e:
                    print("failed to get cover art from LastFM:", e)

        if artist and title:
            cover_from_lastfm = LastFM.get_track_info(artist, title)
            cover_url = cover_from_lastfm.get('album_image')
            debug(cover_url = cover_url, debug = 1)
            debug(to_file = to_file, debug = 1)
            cover_file = str(Path(__file__).parent / 'no_cover.png')
            if cover_url and to_file:
                print(make_colors("LastFM Cover writing ...", 'b', 'y'))
                cover_file = os.path.join(temp_dir, self.normalization_name(title) + (os.path.splitext(cover_url)[-1] or ".jpg"))
                with open(cover_file, 'wb') as cover_data:
                    cover_data.write(get_image(cover_url))
                    debug(cover_file_name = cover_data.name, debug = 1)
                    print(make_colors("LastFM Cover writing finish", 'b', 'ly'))
                    cover_file = cover_data.name
                    
            debug(cover_file = cover_file, debug = 1)   
            if to_file:
                return cover_file
            return cover_url
        return ''

    @MPD.connection_check
    def update_song_info_initialize(self):
        if not self.status == 'initialize':
            self.notify.send(title = 'MPD Ticker ---- initializing ... ' , message = "---- initializing ... \n", icon = self.find_cover_art())
            self.status = 'initialize'
            self.timer_id_init = self.root.after(10000, self.update_song_info_initialize)  # Update every 10 seconds        
        
        host_str = ''
        if not self.HOST in ['127.0.0.1', 'localhost', '1::']:
            host_str = f" [{self.HOST}]"
        debug(host_str = host_str)
        
        self.canvas.delete("text")
        self.canvas.create_text(10, 10, text="---- initializing ... " + host_str, fill=self.title_color, anchor='nw', tags="text")
        self.canvas.create_text(10, 30, text=f"Album: ---- initializing ... (0000)", fill=self.album_color, anchor='nw', tags="text")
        self.canvas.create_text(10, 50, text=f"Artist: ---- initializing ...", fill=self.artist_color, anchor='nw', tags="text")
        
        self.update_image(str(Path(__file__).parent / 'no_cover.png'))
                    
    @MPD.connection_check
    def update_song_info(self):
        if self.timer_id_init:
            self.root.after_cancel(self.timer_id_init)
            self.timer_id_init = None
        if self.timer_id_init_clear:
            self.root.after_cancel(self.timer_id_init_clear)
            self.timer_id_init_clear = None
            
        host_str = ''
        if not self.HOST in ['127.0.0.1', 'localhost', '1::']: host_str = f" [{self.HOST}]"
        debug(host_str = host_str)
        debug(self_status = self.status, debug = 1)
        
        if self.status == 'error':
            self.update_image(str(Path(__file__).parent / 'no_cover.png'))
        else:
            self.update_image()
        
        if not self.status or self.status == 'error':
            if self.timer_id:
                self.root.after_cancel(self.timer_id)
                self.timer_id = None
                
            self.canvas.delete("text")
            self.canvas.create_text(10, 10, text="---- initializing ... " + host_str, fill=self.title_color, anchor='nw', tags="text")
            self.canvas.create_text(10, 30, text=f"Album: ---- initializing ... (0000)", fill=self.album_color, anchor='nw', tags="text")
            self.canvas.create_text(10, 50, text=f"Artist: ---- initializing ...", fill=self.artist_color, anchor='nw', tags="text")
            
            if not self.status: self.update_image(str(Path(__file__).parent / 'no_cover.png'))
            if self.status == 'error':
                self.notify.send(title = 'MPD Ticker ---- disconnected ... ' , message = "---- disconnected ... \n", icon = str(Path(__file__).parent / 'no_cover.png'))
                self.timer_id = self.root.after(10000, self.update_song_info)  # Update every 10 seconds                        
            elif not self.status:
                self.notify.send(title = 'MPD Ticker ---- initializing ... ' , message = "---- initializing ... \n", icon = str(Path(__file__).parent / 'no_cover.png'))
                self.status = 'initialize'
                self.timer_id_error = self.root.after(10000, self.update_song_info)  # Update every 10 seconds        

        else:
            if self.timer_id_error:
                self.root.after_cancel(self.timer_id_error)
                self.timer_id_error = None
                
            song = self.client.currentsong()
            #try:
            status_str = ''
            try:
                status = self.client.status()
                if status.get('state') != 'play': status_str = ' [pause]'
            except:
                status_str = ''
            
            if song != self.current_song:
                self.current_song = song
                self.canvas.delete("text")
                self.canvas.create_text(10, 10, text=song.get('title', 'Unknown Title') + status_str + host_str, fill=self.title_color, anchor='nw', tags="text")
                self.canvas.create_text(10, 30, text=f"Album: {song.get('album', 'Unknown Album')} ({song.get('date', 'Unknown Year')})", fill=self.album_color, anchor='nw', tags="text")
                self.canvas.create_text(10, 50, text=f"Artist: {song.get('artist', 'Unknown Artist')}", fill=self.artist_color, anchor='nw', tags="text")
                self.update_image()
                self.notify.send(title = 'MPD Ticker' + host_str + status_str, message = f"{song.get('title')}\n{song.get('album')}\n{song.get('artist')}\n", icon = self.find_cover_art())
            self.timer_id = self.root.after(10000, self.update_song_info)  # Update every 10 seconds
            #except Exception as e:
                #print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Could not fetch song info', 'lw', 'bl')} {make_colors('[2]', 'b', 'ly')}: {make_colors(e, 'lw', 'r')}")
                #if os.getenv('traceback') == '1': print(make_colors(traceback.format_exc(), 'lw', 'm'))
                    ##self.connect_to_mpd()  # Try to reconnect if fetching failed            
            #except Exception as e:
                #print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Could not fetch song info', 'lw', 'bl')} {make_colors('[1]', 'b', 'ly')}: {make_colors(e, 'lw', 'r')}")
                #if os.getenv('traceback') == '1': print(make_colors(traceback.format_exc(), 'lw', 'bl'))
                #self.connect_to_mpd()  # Try to reconnect if fetching failed
            
    def update_song_info_initialize_clear(self):
        host_str = ''
        if not self.HOST in ['127.0.0.1', 'localhost', '1::']:
            host_str = f" [{self.HOST}]"
        debug(host_str = host_str)
        
        self.canvas.delete("text")
        self.canvas.create_text(10, 10, text="---- initializing ... " + host_str, fill=self.title_color, anchor='nw', tags="text")
        self.canvas.create_text(10, 30, text=f"Album: ---- initializing ... (0000)", fill=self.album_color, anchor='nw', tags="text")
        self.canvas.create_text(10, 50, text=f"Artist: ---- initializing ...", fill=self.artist_color, anchor='nw', tags="text")
        
        self.update_image(str(Path(__file__).parent / 'no_cover.png'))
        if not self.status == 'initialize':
            self.notify.send(title = 'MPD Ticker ---- initializing ... ' , message = "---- initializing ... \n", icon = self.find_cover_art())
            self.status = 'initialize'
            #self.timer_id_init_clear = self.root.after(10000, self.update_song_info_initialize)  # Update every 10 seconds        
            
    def update_song_info_clear(self):
        if self.timer_id_init_clear:
            self.root.after_cancel(self.timer_id_init_clear)
            self.timer_id_init_clear = None
        host_str = ''
        if not self.HOST in ['127.0.0.1', 'localhost', '1::']:
            host_str = f" [{self.HOST}]"
        debug(host_str = host_str)
        #try:
            #if not self.process.is_alive():
                #self.process.start()
                
        if not self.status:
            self.canvas.delete("text")
            self.canvas.create_text(10, 10, text="---- initializing ... " + host_str, fill=self.title_color, anchor='nw', tags="text")
            self.canvas.create_text(10, 30, text=f"Album: ---- initializing ... (0000)", fill=self.album_color, anchor='nw', tags="text")
            self.canvas.create_text(10, 50, text=f"Artist: ---- initializing ...", fill=self.artist_color, anchor='nw', tags="text")
            
            self.update_image(str(Path(__file__).parent / 'no_cover.png'))
            if not self.status == 'initialize':
                self.notify.send(title = 'MPD Ticker ---- initializing ... ' , message = "---- initializing ... \n", icon = self.find_cover_art())
                self.status = 'initialize'
                #self.root.after(10000, self.update_song_info_initialize)  # Update every 10 seconds        

        else:   
            song = self.client.currentsong()
            #try:
            status_str = ''
            try:
                status = self.client.status()
                if status.get('state') != 'play':
                    status_str = ' [pause]'
            except:
                status_str = ''
            
            if song != self.current_song:
                self.current_song = song
                self.canvas.delete("text")
                self.canvas.create_text(10, 10, text=song.get('title', 'Unknown Title') + status_str + host_str, fill=self.title_color, anchor='nw', tags="text")
                self.canvas.create_text(10, 30, text=f"Album: {song.get('album', 'Unknown Album')} ({song.get('date', 'Unknown Year')})", fill=self.album_color, anchor='nw', tags="text")
                self.canvas.create_text(10, 50, text=f"Artist: {song.get('artist', 'Unknown Artist')}", fill=self.artist_color, anchor='nw', tags="text")
                self.update_image()
                self.notify.send(title = 'MPD Ticker' + host_str + status_str, message = f"{song.get('title')}\n{song.get('album')}\n{song.get('artist')}\n", icon = self.find_cover_art())
            self.timer_id_clear = self.root.after(10000, self.update_song_info)  # Update every 10 seconds
            #except Exception as e:
                #print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Could not fetch song info', 'lw', 'bl')} {make_colors('[2]', 'b', 'ly')}: {make_colors(e, 'lw', 'r')}")
                #if os.getenv('traceback') == '1': print(make_colors(traceback.format_exc(), 'lw', 'm'))
                    ##self.connect_to_mpd()  # Try to reconnect if fetching failed            
            #except Exception as e:
                #print(f"{make_colors(datetime.strftime(datetime.now(),  '%Y/%m/%d %H:%M:%S,%f'), 'b', 'ly')} {make_colors('Could not fetch song info', 'lw', 'bl')} {make_colors('[1]', 'b', 'ly')}: {make_colors(e, 'lw', 'r')}")
                #if os.getenv('traceback') == '1': print(make_colors(traceback.format_exc(), 'lw', 'bl'))
                #self.connect_to_mpd()  # Try to reconnect if fetching failed
            
    
    def update_image(self, picture_path = None):
        debug(picture_path = picture_path, debug = 1)
        debug(self_status = self.status, debug = 1)
        if self.status == 'error':
            picture_path = str(Path(__file__).parent / 'no_cover.png')
            debug(picture_path = picture_path, debug = 1)
            self.original_image = Image.open(picture_path)
            self.resize_image_to_text_height()
        else:
            try:
                picture_path = self.find_cover_art()
            except:
                picture_path = self.update_image(str(Path(__file__).parent / 'no_cover.png'))
            debug(picture_path = picture_path, debug = 1)
            self.original_image = Image.open(picture_path)
            self.resize_image_to_text_height()
            
    def read_picture(self):
        # Implement this function to read the picture associated with the current song
        return "icon.png"  # Replace with actual picture path

    def quit(self, event=None):
        #self.process.terminate()
        try:
            self.client.disconnect()
        except:
            pass
        self.root.after_cancel(self.ticker_job)  # Cancel the scheduled update_ticker call
        self.save_position()  # Save position on quit
        self.root.destroy()

    def set_always_on_top(self, event):
        self.root.attributes("-topmost", True)

    def set_normal(self, event):
        self.root.attributes("-topmost", False)

    #def start_move(self, event):
        #self.x_offset = event.x
        #self.y_offset = self.y_offset = event.y

    #def do_move(self, event):
        #x = self.root.winfo_pointerx() - self.x_offset
        #y = self.root.winfo_pointery() - self.y_offset
        #self.root.geometry(f"+{x}+{y}")

if __name__ == "__main__":
    root = tk.Tk()
    text = "TRACK.TITLE\nAlbum: ALBUM\nArtist: ARTIST"
    app = Ticker(root, text)
    root.mainloop()
    
    #c = Music()
    #print("current song:", c.currentsong())
